// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { SubjectEntity } from "@comet/cms-api";
import { FindOptions } from "@mikro-orm/core";
import { InjectRepository } from "@mikro-orm/nestjs";
import { EntityManager, EntityRepository } from "@mikro-orm/postgresql";
import { Args, ID, Mutation, Query, Resolver } from "@nestjs/graphql";

import { BrevoContact } from "../entity/brevo-contact.entity";
import { BrevoContactsService } from "./brevo-contacts.service";
import { BrevoContactInput, BrevoContactUpdateInput } from "./dto/brevo-contact.input";
import { BrevoContactsArgs } from "./dto/brevo-contacts.args";
import { PaginatedBrevoContacts } from "./dto/paginated-brevo-contacts";

@Resolver(() => BrevoContact)
export class BrevoContactResolver {
    constructor(
        private readonly entityManager: EntityManager,
        private readonly brevoContactsService: BrevoContactsService,
        @InjectRepository(BrevoContact) private readonly repository: EntityRepository<BrevoContact>,
    ) {}

    @Query(() => BrevoContact)
    @SubjectEntity(BrevoContact)
    async brevoContact(@Args("id", { type: () => ID }) id: string): Promise<BrevoContact> {
        const brevoContact = await this.repository.findOneOrFail(id);
        return brevoContact;
    }

    @Query(() => PaginatedBrevoContacts)
    async brevoContacts(@Args() { filter, sort, offset, limit }: BrevoContactsArgs): Promise<PaginatedBrevoContacts> {
        const where = this.brevoContactsService.getFindCondition({ filter });

        const options: FindOptions<BrevoContact> = { offset, limit };

        if (sort) {
            options.orderBy = sort.map((sortItem) => {
                return {
                    [sortItem.field]: sortItem.direction,
                };
            });
        }

        const [entities, totalCount] = await this.repository.findAndCount(where, options);
        return new PaginatedBrevoContacts(entities, totalCount);
    }

    @Mutation(() => BrevoContact)
    async createBrevoContact(@Args("input", { type: () => BrevoContactInput }) input: BrevoContactInput): Promise<BrevoContact> {
        const brevoContact = this.repository.create({
            ...input,
        });

        await this.entityManager.flush();

        return brevoContact;
    }

    @Mutation(() => BrevoContact)
    @SubjectEntity(BrevoContact)
    async updateBrevoContact(
        @Args("id", { type: () => ID }) id: string,
        @Args("input", { type: () => BrevoContactUpdateInput }) input: BrevoContactUpdateInput,
    ): Promise<BrevoContact> {
        const brevoContact = await this.repository.findOneOrFail(id);

        brevoContact.assign({
            ...input,
        });

        await this.entityManager.flush();

        return brevoContact;
    }

    @Mutation(() => Boolean)
    @SubjectEntity(BrevoContact)
    async deleteBrevoContact(@Args("id", { type: () => ID }) id: string): Promise<boolean> {
        const brevoContact = await this.repository.findOneOrFail(id);
        await this.entityManager.remove(brevoContact);
        await this.entityManager.flush();
        return true;
    }
}
